# 1주차 과제: JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가
## 목차
##### 1. JVM이란 무엇인가
##### 2. 컴파일 하는 방법
##### 3. 실행하는 방법
##### 4. 바이트코드란 무엇인가
##### 5. JIT 컴파일러란 무엇이며 어떻게 동작하는지
##### 6. JVM 구성 요소
##### 7. JDK와 JRE의 차이

## 1. JVM
### 1) JVM이란
자바를 실행하기 위한 가상 기계 <br>
자바를 실행하기 위한 가상 컴퓨터
<br><br>
### 2) 일반 애플리케이션 코드와 자바 애플리케이션의 비교
**일반 애플리케이션 코드**
<br>
(애플리케이션) - (OS) - (하드웨어)

**자바 애플리케이션 코드**
<br>
(자바 애플리케이션) - (JVM) - (OS) - (하드웨어)
<br>

- JVM을 한 번 더 거침
- 하드웨어에 맞게 완전 컴파일된 상태가 아니기에 실행 시 해석(interpret)되기 때문에 속도 저하
<br>
<br>
-> 바이트코드 : <br>
(컴파일된 자바코드 - JVM이 이해할 수 있는 기계어, JVM은 바이트코드를 해당 OS의 기계어로 변환, OS로 전달) <br>
하드웨어의 기계어로 바로 변환해주는 JIT컴파일러, 향상된 최적화 기술로 속도 저하 감소

<br><br>
## 2. 컴파일
### 1) 컴파일이란
프로그래밍 언어로 작성한 코드를 기계가 알아들을 수 있도록 다른 언어로 옮기는 작업

### 2) 컴파일 종류
- jsp 파일 : 자동으로 WAS에서 Servlet(java 파일)로 변환 뒤 컴파일(class 파일)<br>
- java 파일 : class 파일로  컴파일
- 리눅스 컴파일 과정 :<br><br>
1	**program.c** <br>
	전처리기(Preprocessor)<br>
	전처리기 구문(#으로 시작하는 구문)을 처리하는 것<br><br>
2	**program.i** <br>
	컴파일러(Compiler)<br>
	고수준 언어를 저수준 언어로 나타내는 역할<br>
	(저수준언어 : 기계어와 가장 가까운 언어)<br><br>
3	**program.s** <br>
	어셈블러(Assembler)<br>
	완전히 기계어로 바꾸어 주는 역할<br><br>
4	**program.o** <br>
	링커(Linker)<br>
	연결해주는 역할<br>
	여러개의 오브젝트 파일을 하나로 합치거나 라이브러리를 합칠 때 필요<br><br>
5	**program.exe ** <br>

<br><br>
## 3. 실행
### 1) Terminal을 사용한 Java 실행 과정
- Terminal 사용 이유 : <br>
IDE 툴이 어떤 기능을 제공하는지, 소스코드 파일 실행 과정은 어떻게 이루어져있는지 이해하기 위해

####  1))  java 파일 생성하기
- 메모장 간단한 소스코드 작성
- 확장자 .java로 변경
<br>

####  2)) cmd 창으로 java 실행해보기
- 경로 입력
<br>

####  3)) 컴파일

- Javac는 자바 개발 키트(JDK)에 포함된 Java Compiler
- 자바 컴파일러는 .java 파일을 .class로 변경(소스코드를 실행파일로 변환한 것)
- .class파일은 binary code로 이루어져 있다
- javac classpathTest.java 입력, 오류 없을 시 아무런 메시지 없음
- classpathTest.class, Display.class 두 파일이 생김(클래스가 두 개 였기 때문)
<br>

#### 4)) class 파일 실행

- .class 파일 실행 시에는 확장자 제외 파일명만 입력
- 실행시키려면 main method가 있어야함(질문) 왜 main 없으면 안되냐
- java ClasspathTest 입력
- 결과 출력

<br><br>
## 4. 바이트코드( = Bytecode, portable code, p-code)
- 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법
- 하드웨어가 아닌 소프트웨어에 의해 처리되기 때문에, 보통 기계어보다 더 추상적
- 바이트코드 프로그램은 보통 한 번에 하나의 명령어를 읽은 후 실행
- 바이트코드 인터프리터는 높은 이식성을 갖는다
- JVM이 이해할 수 있는 언어, Java는 OS에 독립적이기 때문에 JVM이 이해할 수 있는 언어로 제공해야함, Java 컴파일러를 통해 바이트코드로 컴파일

**소스 코드(<-> 바이트코드)**
추상도 :  기계어 < 바이트코드 < 소스코드  
바이트 코드 : 추상↓ 간결↑ 컴퓨터 중심적↑

<br><br>
## 5. JIT(Just In Time)
- 인터프리터의 한 종류
(
인터프리터
(interpreter)
프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경
원시 코드를 기계어로 번역하는 컴파일러와 대비
)
- 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법
- 코드가 실행되는 과정에 실시간으로 일어남 (Just-In-Time)
- JIT 컴파일러가 런타임에 Java의 성능을 향상시키는 Java Runtime Environment의 구성 요소

**JIT의 역할**
- JAVA는 바이트코드(.class)로 컴파일 하는 과정과, 바이트코드를 인터프리터 하는 과정을 2번을 진행 : 때문에 컴파일속도가 느린편
- 인터프리터 방식의 단점을 보완하기 위해 도입
- 실행 시점에 인터프리터 방식으로 기계어 코드를 생성, 캐싱
- 캐싱을 통해 필요할때마다 사용하여 빠르게 처리
<br>

**프로그램을 만드는 방법 **
1) 인터프리터 방식 
<br>소스코드를 빌드시에 아무것도 하지 않다가, 런타임시에 한줄 씩 변환
- 인터프리트 방식 : 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행
바이트코드, 소스코드를 최적화 과정 없이 번역, 성능 낮음

2) 컴파일 방식
<br>소스코드를 한 번에 컴퓨터가 읽을 수 있도록 기계어로 변환
- 정적 컴파일 방식 : 실행하기 전에 프로그램 코드를 기계어로 번역
실행 전에 무조건 컴파일, 다양한 플랫폼에 맞추기 위해 시간이 오래 걸림
- 동적 컴파일 언어 : 실행 과정에서 컴파일 하기 위해 만들어짐

->
**JIT :**
정적 컴파일만큼 빠르면서 인터프러터 언어의 빠른 응답 속도를 추구하기 위해 사용
바이트코드 컴파일러가 시간이 많이 소요되는 최적화를 미리 해준다
<br>

**자바 컴파일러 : **
1) 자바 프로그램 코드를 바이트코드로 변환 
2) 바이트코드를 실행하는 시점에서 자바 가상 머신이 바이트코드를 JIT 컴파일을 통해 기계어로 변환
전체 코드의 필요한 부분만 변환
변환 코드 캐시에 저장, 컴파일 다시 할 필요 없음

![image](https://user-images.githubusercontent.com/85435031/180199678-5cfca77d-0784-459b-858d-fd771dd27d3f.png)

<br><br>
## 6. JVM
![img1 daumcdn](https://user-images.githubusercontent.com/85435031/180201495-849f7f7e-2150-4eb8-8fbc-69c40f415697.png)
**Class Loader**
- 로딩 → 링킹(linking) (래퍼런스 연결) → 초기화(Initialization) 세가지 기능 동작
- 자바 컴파일러를 통해 바이트 코드(.class)로 변환된 바이트 코드를 JVM에 로딩, 링킹, 초기화 시키는 역할, Method Area에 적재, 로딩이 끝나면 Heap Area에 적재
- Linking은 검증(Verify)을 통해 .class 파일 형식이 유효한지 체크와 (Preparation) 클래스 변수(static)의 필요한 메모리, (Resolve) 메모리 래퍼런스를 Method 영역에 있는 실제 래퍼런스로 교체
- Initailization, Static 변수의 값 할당
- 바이트 코드(.class)를 필요할 때마다 동적으로 올림

**Memory 관리**
- Method Area는 field, method, tpye constant pool, static, final 등 관리
- Heap Area는 모든 객체와 인스턴스 변수, 배열 등 저장
- Statck Area는 지역 변수, thread 관리
- PC register는 운영체제에서 관리하는 context switch가 발생할때 사용
- Native Method Stack은 자바가 아닌 다른 언어로 작성된 코드 실행 시 사용

**Execution engine**
- 로드된 바이트코드(.class) 실행 엔진
- 바이트코드를 명령어 단위로 읽어서 실행
- 인터프리터 방식과 JIT 방식 사용
- JIT으로 중복되는 부분을 미리 체크하고 라인별로 인터프리터 방식으로 실행
- 체크한 부분에 도달하면 미리 캐시된 값을 실행하는 방식으로 진행한다.
- GC(Garbage Collection) : 
더이상 사용하지 않는 인스턴스들을 삭제하는 역할 수행
GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업 총칭
JAVA는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기 때문에 객체를 사용하고 제거하는 기능이 필요

<br><br>
## 7. JDK와 JRE의 차이
**JRE(Java Runtime Environment)**
- Java 애플리케이션을 생성하고 실행하기 위한 일련의 구성요소
- JRE는 Java프로그램을 실행하는 환경을 제공
<br>

**JDK(Java Development Kit)**
- JRE + 개발에 필요한 것들을 가지고 있는 더 큰 범위
- Java 프로그램 개발과 실행을 할 수 있는 환경을 제공

